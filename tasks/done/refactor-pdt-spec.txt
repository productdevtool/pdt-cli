Phase 1: Foundational Changes & Initial AI CallThis phase adapts the existing command structure to support the new conversational workflow and implements the first AI call that generates the draft and questions.Step 1: Define and Ensure Spec Directory.At the start of the command, define the path for specs as a variable (e.g., specDir := ".pdt/specs").Check if this directory exists. If not, create it using os.MkdirAll. This ensures the target directory is always available.Step 2: Update Command Signature & Input Handling.Modify the specCmd to accept a natural language string as an argument (e.g., pdt spec "My high-level goal").If no argument is provided, prompt the user to enter their objective interactively.Step 3: Implement Initial Prompt Construction.Create a new function, perhaps in the pkg/prompt package, called InitialPlannerPrompt.This function will take the user's string input and construct the detailed prompt described in "Section 3.2" of the spec, including the project context (directory tree, etc.) and the request for a JSON object containing draftSpec and clarifyingQuestions.Step 4: Update AI Executor and Data Handling.Modify the ai.Executor call to expect a JSON response instead of plain markdown.Add structs in a new types package (e.g., planner.go) to represent the expected JSON structure: PlannerResponse, ClarifyingQuestion.After the AI call, unmarshal the JSON response into these structs. Handle potential JSON parsing errors.Step 5: Save the Initial Draft.Save the draftSpec content from the response to a temporary file within the new specs directory (e.g., .pdt/specs/.spec.draft.md).Phase 2: Building the Interactive Q&A LoopThis is the core interactive component where the CLI dialogues with the user.Step 6: Implement the Dialogue Manager.Check if the clarifyingQuestions array from the AI response is populated.If it is empty, the AI considers the spec complete. For now, simply save the draft spec to the final location (e.g., .pdt/specs/spec.md) and exit. The full "Review & Exit" flow will be added in Phase 4.If there are questions, create a new function startQASession.Step 7: Develop the Interactive Prompting Logic.Inside startQASession, loop through each ClarifyingQuestion object.For each question, display it to the user in a clean format (e.g., [1/3] What should be displayed...).Read the user's answer from standard input.Store the question and the user's response together. A new struct Answer and a slice AnswerSet should be created to hold this data, as described in "Section 4.3".Phase 3: Spec FinalizationThis phase sends the collected answers back to the AI to generate the final, refined specification.Step 8: Implement the Refinement Prompt.Create a new prompt-building function, RefinementPrompt.This function will take the initial draftSpec (read from .pdt/specs/.spec.draft.md) and the AnswerSet collected in the previous phase.It will construct the final prompt as detailed in "Section 5.1", instructing the AI to integrate the answers and return a single, complete markdown string.Step 9: Final AI Call and File I/O.Make a second call to the ai.Executor with the refinement prompt.This time, the response will be the final markdown content.Overwrite the main spec file in its new location (e.g., .pdt/specs/spec.md). A more robust implementation might generate a filename from the task description.Delete the temporary .pdt/specs/.spec.draft.md file.Phase 4: User Review and Workflow IntegrationThis phase adds the final user-facing options and cleans up the old logic.Step 10: Implement the "Next Steps" Menu.After saving the final spec, implement the interactive menu described in "Section 6.2".Present the user with the options: (P)roceed, (R)efine, (E)dit.Implement the logic for each choice:(P)roceed: Exit the application.(R)efine: Re-run the entire loop, using the content of the newly saved spec from .pdt/specs/spec.md as the initial input.(E)dit: Use the os/exec package to open the spec file from its new path in the user's default editor ($EDITOR).Step 11: Remove Legacy Code.Remove the now-obsolete Git integration logic (git add, git commit) from the spec command itself. This is a separate concern and should not be part of the spec generation workflow.Clean up any unused functions related to the old, non-interactive process.
